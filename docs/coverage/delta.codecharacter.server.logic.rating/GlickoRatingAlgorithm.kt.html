<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GlickoRatingAlgorithm.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">server</a> &gt; <a href="index.source.html" class="el_package">delta.codecharacter.server.logic.rating</a> &gt; <span class="el_source">GlickoRatingAlgorithm.kt</span></div><h1>GlickoRatingAlgorithm.kt</h1><pre class="source lang-java linenums">package delta.codecharacter.server.logic.rating

import java.time.Instant
import java.util.concurrent.TimeUnit
import kotlin.math.PI
import kotlin.math.ln
import kotlin.math.max
import kotlin.math.min
import kotlin.math.pow
import kotlin.math.sqrt

/*
   Refer: http://www.glicko.net/glicko/glicko.pdf
*/
<span class="fc" id="L15">class GlickoRatingAlgorithm : RatingAlgorithm {</span>

    // Constant
<span class="fc" id="L18">    private val q: Double = ln(10.0) / 400</span>

    // &quot; One practical problem with the Glicko system is that when a player competes very frequently,
    // his/her rating stops changing appreciably which reflects that the RD is very small. This may
    // sometimes prevent a playerâ€™s rating from changing substantially when the player is truly
    // improving. I would therefore recommend that an RD never drop below a threshold value,
    // such as 30, so that ratings can change appreciably even in a relatively short time.&quot;
    //                          - Mark E Glickman
<span class="fc" id="L26">    private val minRatingDeviation: Double = 30.0</span>

    // Time for one rating period in minutes
<span class="fc" id="L29">    private val timePeriod: Double = 15.0</span>

    // Amount which decides how much a player's rating deviation changes every time period
    // Using timePeriod 15 mins and time to reduce the rating to min rating as 48 hrs,
    // we get the number of time periods to reduce the rating to min rating as 192.
    // Using these we calculate c = sqrt((350**2 - 50**2)/192) = 25, where 50 is
    // the rating deviation of a typical player.
<span class="fc" id="L36">    private val c: Double = 25.0</span>

    // Wont let RD be more than this value
<span class="fc" id="L39">    private val unratedPlayerRD: Double = 350.0</span>

<span class="fc" id="L41">    private fun g(rd: Double): Double = 1.0 / (sqrt(1.0 + ((3.0 * q * q * rd * rd)) / (PI * PI)))</span>

    private fun e(r0: Double, rI: Double, rdI: Double): Double {
<span class="fc" id="L44">        val grdI = g(rdI)</span>
<span class="fc" id="L45">        val ratingDiff = r0 - rI</span>
<span class="fc" id="L46">        return 1.0 / (1.0 + ((10.0).pow((grdI * ratingDiff) / (-400.0))))</span>
    }

    private fun dSquared(
        r0: Double,
        opponentRatings: List&lt;GlickoRating&gt;,
    ): Double {
<span class="fc" id="L53">        var sm = 0.0</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        for (oppRating in opponentRatings) {</span>
<span class="fc" id="L55">            val rI = oppRating.rating</span>
<span class="fc" id="L56">            val rdI = oppRating.ratingDeviation</span>
<span class="fc" id="L57">            val grd = g(rdI)</span>
<span class="fc" id="L58">            val expectation = e(r0, rI, rdI)</span>
<span class="fc" id="L59">            sm += (grd * grd * expectation * (1.0 - expectation))</span>
        }
<span class="fc" id="L61">        return 1.0 / (q * q * sm)</span>
    }

    override fun calculateNewRating(
        rating: GlickoRating,
        opponentRatings: List&lt;GlickoRating&gt;,
        opponentOutcomes: List&lt;Double&gt;,
    ): GlickoRating {
<span class="fc" id="L69">        val r0 = rating.rating</span>
<span class="fc" id="L70">        var sm = 0.0</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        for ((i, opponentRating) in opponentRatings.withIndex()) {</span>
<span class="fc" id="L72">            val rI = opponentRating.rating</span>
<span class="fc" id="L73">            val rdI = opponentRating.ratingDeviation</span>
<span class="fc" id="L74">            val grd = g(rdI)</span>
<span class="fc" id="L75">            val expectation = e(r0, rI, rdI)</span>
<span class="fc" id="L76">            val sI = opponentOutcomes[i]</span>
<span class="fc" id="L77">            sm += (grd * (sI - expectation))</span>
        }
<span class="fc" id="L79">        val rd = rating.ratingDeviation</span>
<span class="fc" id="L80">        val d2 = dSquared(r0, opponentRatings)</span>
<span class="fc" id="L81">        val numerator = q * sm</span>
<span class="fc" id="L82">        val denominator = (1.0 / (rd * rd)) + (1.0 / d2)</span>

<span class="fc" id="L84">        val newR = r0 + (numerator / denominator)</span>
<span class="fc" id="L85">        val newRd = max(minRatingDeviation, sqrt(1.0 / ((1.0 / (rd * rd)) + (1.0 / d2))))</span>

<span class="fc" id="L87">        return GlickoRating(newR, newRd)</span>
    }

    override fun getWeightedRatingDeviationSinceLastCompetition(
        lastRD: Double,
        lastMatchDate: Instant,
    ): Double {
<span class="nc" id="L94">        val currentInstant = Instant.now()</span>
<span class="nc" id="L95">        val offset = currentInstant.toEpochMilli() - lastMatchDate.toEpochMilli()</span>
<span class="nc" id="L96">        val noOfTimePeriodsElapsed = TimeUnit.MILLISECONDS.toMinutes(offset).toDouble() / timePeriod</span>
<span class="nc" id="L97">        return min(unratedPlayerRD, sqrt((lastRD * lastRD) + (c * c * noOfTimePeriodsElapsed)))</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>